## docker push, data scaling


#### docker push

오늘은 먼저 docker image를 push하는 방법에 대해 알아보았다.

어제 docker를 build할 때, toml파일의 dependency를 받아오는 데에 시간이 많이 걸렸다.

이 때 일종의 트릭으로 dependency가 모두 추가되어있는 docker image를 hub에 올려두면 나중에 다시 받을 때 시간을 대폭 단축시킬 수 있다.

```bash
$ sudo docker login
$ sudo docker build --no-cache -t <dockerID>/<imageName>:<tag> .
$ sudo docker push <dockerID>/<imageName>:<tag>
```

```bash
$ sudo docker system df             # docker 용량 확인
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          2         2         1.738GB   929.1MB (53%)
Containers      4         4         2.077MB   0B (0%)
Local Volumes   72        0         0B        0B
Build Cache     87        0         2.985GB   2.985GBi

$ sudo docker buildx prune          # docker cache 삭제
WARNING! This will remove all dangling build cache. Are you sure you want to continue? [y/N] y

$ sudo docker system df
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          2         2         1.738GB   929.1MB (53%)
Containers      4         4         2.077MB   0B (0%)
Local Volumes   72        0         0B        0B
Build Cache     24        0         0B        0B
```

#### Scaling

어제까지 사용한 예측모델에 대해서 조금 더 알아보았다.

길이가 20이고 무게가 150인 데이터에 대해 예측을 해보면 "빙어"가 나타난다.

```python
>>> knn=KNeighborsClassifier(n_neighbors=5)
>>> knn.fit(fish_data,fish_target)

>>> knn.predict([[25, 150]]])
array([0.])         # 0: 빙어, 1: 도미
```

하지만 해당 데이터를 그래프에 표시해보면 아래와 같이 도미에 더 가까운 모습인 것을 알 수 있다.
```python
>>> plt.scatter(fish_data[:35,0],fish_data[:35,1],color="#F9A8A0")
>>> plt.scatter(fish_data[35:,0],fish_data[35:,1],color="#CFE6CC")
>>> plt.xlabel("length")
>>> plt.ylabel("weight")

>>> plt.scatter(25,150,marker="*", color="r")

>>> plt.show()
```
[여기에 그림1]

도미에 더 가깝게 보이는데 왜 예측은 빙어로 나타나는 것인지 알기 위해서는 x축의 범위를 조절해보면 알 수 있다.

```python
>>> plt.scatter(fish_data[:35,0],fish_data[:35,1],color="#F9A8A0")
>>> plt.scatter(fish_data[35:,0],fish_data[35:,1],color="#CFE6CC")
>>> plt.xlabel("length")
>>> plt.ylabel("weight")

>>> plt.scatter(25,150,marker="*", color="r")

>>> plt.xlim((0,1000))

>>> plt.show()
```
[여기에 그림2]

위 그래프와는 다르게 빙어와도 상당히 가까운 모습을 볼 수 있다. 이는 길이와 무게가 값의 범위 내지는 단위가 달라서 나타나는 문제이다.

이를 해결하기 위해서 표준정규분포로 scaling해줄 수 있다. 

표준정규분포는 평균이 0, 표준편차가 1인 분포이다. 데이터를 표준정규분포를 따르도록 만들면 모든 데이터에서 scale이 동일해져서 비교하기가 쉬워진다.

데이터를 표준정규분포로 변환하는 것은 다음과 같이 할 수 있다.
$$ Z = \frac{X - mean}{standard deviation}$$

그러면 아래와 같이 할 수 있다.

```python
>> scaled_fish = (fish_data - np.mean(fish_data,axis=0))/np.std(fish_data,axis=0)
>> scaled_data = ([25,150] - np.mean(fish_data,axis=0))/np.std(fish_data,axis=0)

>> plt.scatter(scaled_fish[:35,0],scaled_fish[:35,1],color="#F9A8A0")
>> plt.scatter(scaled_fish[35:,0],scaled_fish[35:,1],color="#CFE6CC")
>> plt.xlabel("length")
>> plt.ylabel("weight")

>> plt.scatter(scaled_data[0],scaled_data[1],marker="*", color="r")

>> plt.show()
```
그리고 예측 결과를 보면...

```python
>>> knn_scaled=KNeighborsClassifier(n_neighbors=5)
>>> knn_scaled.fit(scaled_fish,fish_target)

>>> knn_scaled.predict([scaled_data])
array([1.])         # 0: 빙어, 1: 도미
```
도미 예측 성공!


### 정리
